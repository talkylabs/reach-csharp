/*
 * This code was generated by
 *  ___ ___   _   ___ _  _    _____ _   _    _  ___   ___      _   ___ ___      ___   _   ___     ___ ___ _  _ ___ ___    _ _____ ___  ___ 
 * | _ \ __| /_\ / __| || |__|_   _/_\ | |  | |/ | \ / / |    /_\ | _ ) __|___ / _ \ /_\ |_ _|__ / __| __| \| | __| _ \  /_\_   _/ _ \| _ \
 * |   / _| / _ \ (__| __ |___|| |/ _ \| |__| ' < \ V /| |__ / _ \| _ \__ \___| (_) / _ \ | |___| (_ | _|| .` | _||   / / _ \| || (_) |   /
 * |_|_\___/_/ \_\___|_||_|    |_/_/ \_\____|_|\_\ |_| |____/_/ \_\___/___/    \___/_/ \_\___|   \___|___|_|\_|___|_|_\/_/ \_\_| \___/|_|_\
 *                                                                                                                                         
 * Reach Messaging API
 * Reach SMS API helps you add robust messaging capabilities to your applications.  Using this REST API, you can * send SMS messages * track the delivery of sent messages * schedule SMS messages to send at a later time * retrieve and modify message history
 *
 * NOTE: This class is auto generated by OpenAPI Generator.
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


using Newtonsoft.Json;
using System;
using System.Collections.Generic;
using Reach.Base;
using Reach.Clients;
using Reach.Converters;
using Reach.Exceptions;
using Reach.Http;



namespace Reach.Rest.Api.Messaging
{
    public class MessagingItemResource : Resource
    {
    

        
        /// <summary> This operation allows to delete a message record from the applet account. Once the record is deleted, it will no longer appear in the API and the applet portal.  This operation needs the `messageId` of the message to be deleted. To delete multiple messages, this operation should be called as many times as needed since it can only delete one message at a time. Note: Attempting to delete an in-progress message record, i.e. a message whose status is not `delivered`, `failed`, `canceled`, `undelivered`, will result in an error.    </summary>
        /// <param name="options"> Delete MessagingItem parameters </param>
        /// <param name="client"> Client to make requests to Reach(TalkyLabs) </param>
        /// <returns> A single instance of MessagingItem </returns>
        private static Request BuildDeleteRequest(DeleteMessagingItemOptions options, IReachRestClient client)
        {
            
            string path = "/rest/messaging/v1/delete";


            return new Request(
                HttpMethod.Delete,
                Rest.Domain.Api,
                path,
                queryParams: options.GetParams(),
                headerParams: null
            );
        }

        /// <summary> This operation allows to delete a message record from the applet account. Once the record is deleted, it will no longer appear in the API and the applet portal.  This operation needs the `messageId` of the message to be deleted. To delete multiple messages, this operation should be called as many times as needed since it can only delete one message at a time. Note: Attempting to delete an in-progress message record, i.e. a message whose status is not `delivered`, `failed`, `canceled`, `undelivered`, will result in an error.    </summary>
        /// <param name="options"> Delete MessagingItem parameters </param>
        /// <param name="client"> Client to make requests to Reach(TalkyLabs) </param>
        /// <returns> A single instance of MessagingItem </returns>
        public static bool Delete(DeleteMessagingItemOptions options, IReachRestClient client = null)
        {
            client = client ?? ReachClient.GetRestClient();
            var response = client.Request(BuildDeleteRequest(options, client));
            return response.StatusCode == System.Net.HttpStatusCode.NoContent;
        }

        #if !NET35
        /// <summary> This operation allows to delete a message record from the applet account. Once the record is deleted, it will no longer appear in the API and the applet portal.  This operation needs the `messageId` of the message to be deleted. To delete multiple messages, this operation should be called as many times as needed since it can only delete one message at a time. Note: Attempting to delete an in-progress message record, i.e. a message whose status is not `delivered`, `failed`, `canceled`, `undelivered`, will result in an error.    </summary>
        /// <param name="options"> Delete MessagingItem parameters </param>
        /// <param name="client"> Client to make requests to Reach(TalkyLabs) </param>
        /// <returns> Task that resolves to A single instance of MessagingItem </returns>
        public static async System.Threading.Tasks.Task<bool> DeleteAsync(DeleteMessagingItemOptions options,
                                                                          IReachRestClient client = null)
        {
            client = client ?? ReachClient.GetRestClient();
            var response = await client.RequestAsync(BuildDeleteRequest(options, client));
            return response.StatusCode == System.Net.HttpStatusCode.NoContent;
        }
        #endif

        /// <summary> This operation allows to delete a message record from the applet account. Once the record is deleted, it will no longer appear in the API and the applet portal.  This operation needs the `messageId` of the message to be deleted. To delete multiple messages, this operation should be called as many times as needed since it can only delete one message at a time. Note: Attempting to delete an in-progress message record, i.e. a message whose status is not `delivered`, `failed`, `canceled`, `undelivered`, will result in an error.    </summary>
        /// <param name="messageId"> The identifier of the message to be updated. </param>
        /// <param name="client"> Client to make requests to Reach(TalkyLabs) </param>
        /// <returns> A single instance of MessagingItem </returns>
        public static bool Delete(string messageId, IReachRestClient client = null)
        {
            var options = new DeleteMessagingItemOptions(messageId)     ;
            return Delete(options, client);
        }

        #if !NET35
        /// <summary> This operation allows to delete a message record from the applet account. Once the record is deleted, it will no longer appear in the API and the applet portal.  This operation needs the `messageId` of the message to be deleted. To delete multiple messages, this operation should be called as many times as needed since it can only delete one message at a time. Note: Attempting to delete an in-progress message record, i.e. a message whose status is not `delivered`, `failed`, `canceled`, `undelivered`, will result in an error.    </summary>
        /// <param name="messageId"> The identifier of the message to be updated. </param>
        /// <param name="client"> Client to make requests to Reach(TalkyLabs) </param>
        /// <returns> Task that resolves to A single instance of MessagingItem </returns>
        public static async System.Threading.Tasks.Task<bool> DeleteAsync(string messageId, IReachRestClient client = null)
        {
            var options = new DeleteMessagingItemOptions(messageId) ;
            return await DeleteAsync(options, client);
        }
        #endif
        
        private static Request BuildFetchRequest(FetchMessagingItemOptions options, IReachRestClient client)
        {
            
            string path = "/rest/messaging/v1/fetch";


            return new Request(
                HttpMethod.Get,
                Rest.Domain.Api,
                path,
                queryParams: options.GetParams(),
                headerParams: null
            );
        }

        /// <summary> This operation allows to fetch the API record associated to a message.  This operation needs the `messageId` of the message to be fetched.    </summary>
        /// <param name="options"> Fetch MessagingItem parameters </param>
        /// <param name="client"> Client to make requests to Reach(TalkyLabs) </param>
        /// <returns> A single instance of MessagingItem </returns>
        public static MessagingItemResource Fetch(FetchMessagingItemOptions options, IReachRestClient client = null)
        {
            client = client ?? ReachClient.GetRestClient();
            var response = client.Request(BuildFetchRequest(options, client));
            return FromJson(response.Content);
        }

        #if !NET35
        /// <summary> This operation allows to fetch the API record associated to a message.  This operation needs the `messageId` of the message to be fetched.    </summary>
        /// <param name="options"> Fetch MessagingItem parameters </param>
        /// <param name="client"> Client to make requests to Reach(TalkyLabs) </param>
        /// <returns> Task that resolves to A single instance of MessagingItem </returns>
        public static async System.Threading.Tasks.Task<MessagingItemResource> FetchAsync(FetchMessagingItemOptions options,
                                                                                             IReachRestClient client = null)
        {
            client = client ?? ReachClient.GetRestClient();
            var response = await client.RequestAsync(BuildFetchRequest(options, client));
            return FromJson(response.Content);
        }
        #endif
        /// <summary> This operation allows to fetch the API record associated to a message.  This operation needs the `messageId` of the message to be fetched.    </summary>
        /// <param name="messageId"> The identifier of the message to be updated. </param>
        /// <param name="client"> Client to make requests to Reach(TalkyLabs) </param>
        /// <returns> A single instance of MessagingItem </returns>
        public static MessagingItemResource Fetch(
                                         string messageId, 
                                         IReachRestClient client = null)
        {
            var options = new FetchMessagingItemOptions(messageId){  };
            return Fetch(options, client);
        }

        #if !NET35
        /// <summary> This operation allows to fetch the API record associated to a message.  This operation needs the `messageId` of the message to be fetched.    </summary>
        /// <param name="messageId"> The identifier of the message to be updated. </param>
        /// <param name="client"> Client to make requests to Reach(TalkyLabs) </param>
        /// <returns> Task that resolves to A single instance of MessagingItem </returns>
        public static async System.Threading.Tasks.Task<MessagingItemResource> FetchAsync(string messageId, IReachRestClient client = null)
        {
            var options = new FetchMessagingItemOptions(messageId){  };
            return await FetchAsync(options, client);
        }
        #endif
        
        private static Request BuildReadRequest(ReadMessagingItemOptions options, IReachRestClient client)
        {
            
            string path = "/rest/messaging/v1/list";


            return new Request(
                HttpMethod.Get,
                Rest.Domain.Api,
                path,
                queryParams: options.GetParams(),
                headerParams: null
            );
        }
        /// <summary> This operation allows to retrieve from the API message records that satisfied specified criteria.  When getting the message record list, results will be sorted on the `dateSent` field with the most recent message records appearing first.    </summary>
        /// <param name="options"> Read MessagingItem parameters </param>
        /// <param name="client"> Client to make requests to Reach(TalkyLabs) </param>
        /// <returns> A single instance of MessagingItem </returns>
        public static ResourceSet<MessagingItemResource> Read(ReadMessagingItemOptions options, IReachRestClient client = null)
        {
            client = client ?? ReachClient.GetRestClient();
            var request = BuildReadRequest(options, client);
            var url = request.GetUrlStringWithoutPaginationInfo();
            var response = client.Request(request);
            var page = Page<MessagingItemResource>.FromJson(url, "messages", response.Content);
            return new ResourceSet<MessagingItemResource>(page, options, client);
        }

        #if !NET35
        /// <summary> This operation allows to retrieve from the API message records that satisfied specified criteria.  When getting the message record list, results will be sorted on the `dateSent` field with the most recent message records appearing first.    </summary>
        /// <param name="options"> Read MessagingItem parameters </param>
        /// <param name="client"> Client to make requests to Reach(TalkyLabs) </param>
        /// <returns> Task that resolves to A single instance of MessagingItem </returns>
        public static async System.Threading.Tasks.Task<ResourceSet<MessagingItemResource>> ReadAsync(ReadMessagingItemOptions options,
                                                                                             IReachRestClient client = null)
        {
            client = client ?? ReachClient.GetRestClient();
            var request = BuildReadRequest(options, client);
            var url = request.GetUrlStringWithoutPaginationInfo();
            var response = await client.RequestAsync(request);

            var page = Page<MessagingItemResource>.FromJson(url, "messages", response.Content);
            return new ResourceSet<MessagingItemResource>(page, options, client);
        }
        #endif
        /// <summary> This operation allows to retrieve from the API message records that satisfied specified criteria.  When getting the message record list, results will be sorted on the `dateSent` field with the most recent message records appearing first.    </summary>
        /// <param name="dest"> Retrieve messages sent to only this phone number. The phone number in E.164 format of the message. </param>
        /// <param name="src"> Retrieve messages sent from only this phone number, in E.164 format, or alphanumeric sender ID. </param>
        /// <param name="bulkIdentifier"> Retrieve only messages that are assocaited with this `bulkIdentifier`. </param>
        /// <param name="sentAt"> Retrieve only messages sent at the specified date. Must be in ISO 8601 format. </param>
        /// <param name="sentAfter"> Retrieve only messages sent after the specified datetime. Must be in ISO 8601 format. </param>
        /// <param name="sentBefore"> Retrieve only messages sent before the specified datetime. Must be in ISO 8601 format. </param>
        /// <param name="pageSize"> Maximum number of records to return per call. </param>
        /// <param name="limit"> Record limit </param>
        /// <param name="client"> Client to make requests to Reach(TalkyLabs) </param>
        /// <returns> A single instance of MessagingItem </returns>
        public static ResourceSet<MessagingItemResource> Read(
                                                     string dest = null,
                                                     string src = null,
                                                     string bulkIdentifier = null,
                                                     DateTime? sentAt = null,
                                                     DateTime? sentAfter = null,
                                                     DateTime? sentBefore = null,
                                                     int? pageSize = null,
                                                     long? limit = null,
                                                     IReachRestClient client = null)
        {
            var options = new ReadMessagingItemOptions(){ Dest = dest, Src = src, BulkIdentifier = bulkIdentifier, SentAt = sentAt, SentAfter = sentAfter, SentBefore = sentBefore, PageSize = pageSize, Limit = limit};
            return Read(options, client);
        }

        #if !NET35
        /// <summary> This operation allows to retrieve from the API message records that satisfied specified criteria.  When getting the message record list, results will be sorted on the `dateSent` field with the most recent message records appearing first.    </summary>
        /// <param name="dest"> Retrieve messages sent to only this phone number. The phone number in E.164 format of the message. </param>
        /// <param name="src"> Retrieve messages sent from only this phone number, in E.164 format, or alphanumeric sender ID. </param>
        /// <param name="bulkIdentifier"> Retrieve only messages that are assocaited with this `bulkIdentifier`. </param>
        /// <param name="sentAt"> Retrieve only messages sent at the specified date. Must be in ISO 8601 format. </param>
        /// <param name="sentAfter"> Retrieve only messages sent after the specified datetime. Must be in ISO 8601 format. </param>
        /// <param name="sentBefore"> Retrieve only messages sent before the specified datetime. Must be in ISO 8601 format. </param>
        /// <param name="pageSize"> Maximum number of records to return per call. </param>
        /// <param name="limit"> Record limit </param>
        /// <param name="client"> Client to make requests to Reach(TalkyLabs) </param>
        /// <returns> Task that resolves to A single instance of MessagingItem </returns>
        public static async System.Threading.Tasks.Task<ResourceSet<MessagingItemResource>> ReadAsync(
                                                                                             string dest = null,
                                                                                             string src = null,
                                                                                             string bulkIdentifier = null,
                                                                                             DateTime? sentAt = null,
                                                                                             DateTime? sentAfter = null,
                                                                                             DateTime? sentBefore = null,
                                                                                             int? pageSize = null,
                                                                                             long? limit = null,
                                                                                             IReachRestClient client = null)
        {
            var options = new ReadMessagingItemOptions(){ Dest = dest, Src = src, BulkIdentifier = bulkIdentifier, SentAt = sentAt, SentAfter = sentAfter, SentBefore = sentBefore, PageSize = pageSize, Limit = limit};
            return await ReadAsync(options, client);
        }
        #endif

        
        /// <summary> Fetch the target page of records </summary>
        /// <param name="targetUrl"> API-generated URL for the requested results page </param>
        /// <param name="client"> Client to make requests to Reach(TalkyLabs) </param>
        /// <returns> The target page of records </returns>
        public static Page<MessagingItemResource> GetPage(string targetUrl, IReachRestClient client)
        {
            client = client ?? ReachClient.GetRestClient();

            var request = new Request(
                HttpMethod.Get,
                targetUrl
            );

            var url = request.GetUrlStringWithoutPaginationInfo();
            var response = client.Request(request);
            return Page<MessagingItemResource>.FromJson(url, "messages", response.Content);
        }

        /// <summary> Fetch the next page of records </summary>
        /// <param name="page"> current page of records </param>
        /// <param name="client"> Client to make requests to Reach(TalkyLabs) </param>
        /// <returns> The next page of records </returns>
        public static Page<MessagingItemResource> NextPage(Page<MessagingItemResource> page, IReachRestClient client)
        {
            var request = new Request(
                HttpMethod.Get,
                page.GetNextPageUrl(Rest.Domain.Api)
            );

            var url = request.GetUrlStringWithoutPaginationInfo();
            var response = client.Request(request);
            return Page<MessagingItemResource>.FromJson(url, "messages", response.Content);
        }

        /// <summary> Fetch the previous page of records </summary>
        /// <param name="page"> current page of records </param>
        /// <param name="client"> Client to make requests to Reach(TalkyLabs) </param>
        /// <returns> The previous page of records </returns>
        public static Page<MessagingItemResource> PreviousPage(Page<MessagingItemResource> page, IReachRestClient client)
        {
            var request = new Request(
                HttpMethod.Get,
                page.GetPreviousPageUrl(Rest.Domain.Api)
            );

            var url = request.GetUrlStringWithoutPaginationInfo();
            var response = client.Request(request);
            return Page<MessagingItemResource>.FromJson(url, "messages", response.Content);
        }

        
        private static Request BuildSendRequest(SendMessagingItemOptions options, IReachRestClient client)
        {
            
            string path = "/rest/messaging/v1/create";


            return new Request(
                HttpMethod.Post,
                Rest.Domain.Api,
                path,
                postParams: options.GetParams(),
                headerParams: null
            );
        }

        /// <summary> This operation allows to send or schedule a message.  When sending a new message via the API, you must include the `dest` parameter.          This value should be the destination phone number. You must also include the `body` parameter containing the message's content as well as the `src` parameter   containing the sender alphanumeric Id or number.  To schedule a message, you must additionally pass the following parameter:  * `scheduledTime`: the date and time at which the sms will be sent in the ISO-8601 format.  </summary>
        /// <param name="options"> Send MessagingItem parameters </param>
        /// <param name="client"> Client to make requests to Reach(TalkyLabs) </param>
        /// <returns> A single instance of MessagingItem </returns>
        public static MessagingItemResource Send(SendMessagingItemOptions options, IReachRestClient client = null)
        {
            client = client ?? ReachClient.GetRestClient();
            var response = client.Request(BuildSendRequest(options, client));
            return FromJson(response.Content);
        }

        #if !NET35
        /// <summary> This operation allows to send or schedule a message.  When sending a new message via the API, you must include the `dest` parameter.          This value should be the destination phone number. You must also include the `body` parameter containing the message's content as well as the `src` parameter   containing the sender alphanumeric Id or number.  To schedule a message, you must additionally pass the following parameter:  * `scheduledTime`: the date and time at which the sms will be sent in the ISO-8601 format.  </summary>
        /// <param name="options"> Send MessagingItem parameters </param>
        /// <param name="client"> Client to make requests to Reach(TalkyLabs) </param>
        /// <returns> Task that resolves to A single instance of MessagingItem </returns>
        public static async System.Threading.Tasks.Task<MessagingItemResource> SendAsync(SendMessagingItemOptions options,
        IReachRestClient client = null)
        {
            client = client ?? ReachClient.GetRestClient();
            var response = await client.RequestAsync(BuildSendRequest(options, client));
            return FromJson(response.Content);
        }
        #endif

        /// <summary> This operation allows to send or schedule a message.  When sending a new message via the API, you must include the `dest` parameter.          This value should be the destination phone number. You must also include the `body` parameter containing the message's content as well as the `src` parameter   containing the sender alphanumeric Id or number.  To schedule a message, you must additionally pass the following parameter:  * `scheduledTime`: the date and time at which the sms will be sent in the ISO-8601 format.  </summary>
        /// <param name="dest"> The destination phone number in E.164 format of the message. </param>
        /// <param name="src"> The phone number (in E.164 format), or the alphanumeric sender ID that initiated the message. </param>
        /// <param name="body"> The text of the message to send. It can be up to 1,600 GSM-7 characters in length. That limit varies if your message is not made of only GSM-7 characters. More generally, the message body should not exceed 10 segments. </param>
        /// <param name="bulkIdentifier"> The identifier of the bulk operation this message belongs to. </param>
        /// <param name="scheduledTime"> The datetime at which the message will be sent. Must be in ISO 8601 format. A message must be scheduled at least 15 min in advance of message send time and cannot be scheduled more than 5 days in advance of the request. </param>
        /// <param name="statusCallback"> The URL that will be called to send status information of your message. If provided, the API POST these message status changes to the URL: `queued`, `failed`, `sent`, `canceled`, `delivered`, or `undelivered`. URLs must contain a valid hostname and underscores are not allowed.  </param>
        /// <param name="maxPrice"> The maximum total price in the applet currency that should be paid for the message to be delivered. If the cost exceeds `maxPrice`, the message will fail and a status of `failed` is sent to the status callback.  </param>
        /// <param name="validityPeriod"> It represents how long, in seconds, the message can remain in the queue. After this period elapses, the message fails and the status callback is called. After a message has been accepted by a carrier, however, there is no guarantee that the message will not be queued after this period. It is recommended that this value be at least 5 seconds. The maximum allowed value is 14,400 which corresponds to 4 hours.  </param>
        /// <param name="client"> Client to make requests to Reach(TalkyLabs) </param>
        /// <returns> A single instance of MessagingItem </returns>
        public static MessagingItemResource Send(
                                          string dest,
                                          string src,
                                          string body,
                                          string bulkIdentifier = null,
                                          DateTime? scheduledTime = null,
                                          string statusCallback = null,
                                          decimal? maxPrice = null,
                                          int? validityPeriod = null,
                                          IReachRestClient client = null)
        {
            var options = new SendMessagingItemOptions(dest, src, body){  BulkIdentifier = bulkIdentifier, ScheduledTime = scheduledTime, StatusCallback = statusCallback, MaxPrice = maxPrice, ValidityPeriod = validityPeriod };
            return Send(options, client);
        }

        #if !NET35
        /// <summary> This operation allows to send or schedule a message.  When sending a new message via the API, you must include the `dest` parameter.          This value should be the destination phone number. You must also include the `body` parameter containing the message's content as well as the `src` parameter   containing the sender alphanumeric Id or number.  To schedule a message, you must additionally pass the following parameter:  * `scheduledTime`: the date and time at which the sms will be sent in the ISO-8601 format.  </summary>
        /// <param name="dest"> The destination phone number in E.164 format of the message. </param>
        /// <param name="src"> The phone number (in E.164 format), or the alphanumeric sender ID that initiated the message. </param>
        /// <param name="body"> The text of the message to send. It can be up to 1,600 GSM-7 characters in length. That limit varies if your message is not made of only GSM-7 characters. More generally, the message body should not exceed 10 segments. </param>
        /// <param name="bulkIdentifier"> The identifier of the bulk operation this message belongs to. </param>
        /// <param name="scheduledTime"> The datetime at which the message will be sent. Must be in ISO 8601 format. A message must be scheduled at least 15 min in advance of message send time and cannot be scheduled more than 5 days in advance of the request. </param>
        /// <param name="statusCallback"> The URL that will be called to send status information of your message. If provided, the API POST these message status changes to the URL: `queued`, `failed`, `sent`, `canceled`, `delivered`, or `undelivered`. URLs must contain a valid hostname and underscores are not allowed.  </param>
        /// <param name="maxPrice"> The maximum total price in the applet currency that should be paid for the message to be delivered. If the cost exceeds `maxPrice`, the message will fail and a status of `failed` is sent to the status callback.  </param>
        /// <param name="validityPeriod"> It represents how long, in seconds, the message can remain in the queue. After this period elapses, the message fails and the status callback is called. After a message has been accepted by a carrier, however, there is no guarantee that the message will not be queued after this period. It is recommended that this value be at least 5 seconds. The maximum allowed value is 14,400 which corresponds to 4 hours.  </param>
        /// <param name="client"> Client to make requests to Reach(TalkyLabs) </param>
        /// <returns> Task that resolves to A single instance of MessagingItem </returns>
        public static async System.Threading.Tasks.Task<MessagingItemResource> SendAsync(
                                                                                  string dest,
                                                                                  string src,
                                                                                  string body,
                                                                                  string bulkIdentifier = null,
                                                                                  DateTime? scheduledTime = null,
                                                                                  string statusCallback = null,
                                                                                  decimal? maxPrice = null,
                                                                                  int? validityPeriod = null,
                                                                                  IReachRestClient client = null)
        {
        var options = new SendMessagingItemOptions(dest, src, body){  BulkIdentifier = bulkIdentifier, ScheduledTime = scheduledTime, StatusCallback = statusCallback, MaxPrice = maxPrice, ValidityPeriod = validityPeriod };
            return await SendAsync(options, client);
        }
        #endif
        
        private static Request BuildUnscheduleRequest(UnscheduleMessagingItemOptions options, IReachRestClient client)
        {
            
            string path = "/rest/messaging/v1/unschedule";


            return new Request(
                HttpMethod.Post,
                Rest.Domain.Api,
                path,
                postParams: options.GetParams(),
                headerParams: null
            );
        }

        /// <summary> This operation allows to cancel a previously scheduled message.  This operation needs the `messageId` of the message to be unscheduled. To unschedule multiple messages, this operation should be called as many times needed since it can only unschedule one message at a time.  Note: The system will make the best attempt to cancel a scheduled message when a request is received.  </summary>
        /// <param name="options"> Unschedule MessagingItem parameters </param>
        /// <param name="client"> Client to make requests to Reach(TalkyLabs) </param>
        /// <returns> A single instance of MessagingItem </returns>
        public static MessagingItemResource Unschedule(UnscheduleMessagingItemOptions options, IReachRestClient client = null)
        {
            client = client ?? ReachClient.GetRestClient();
            var response = client.Request(BuildUnscheduleRequest(options, client));
            return FromJson(response.Content);
        }

        /// <summary> This operation allows to cancel a previously scheduled message.  This operation needs the `messageId` of the message to be unscheduled. To unschedule multiple messages, this operation should be called as many times needed since it can only unschedule one message at a time.  Note: The system will make the best attempt to cancel a scheduled message when a request is received.  </summary>
        /// <param name="options"> Unschedule MessagingItem parameters </param>
        /// <param name="client"> Client to make requests to Reach(TalkyLabs) </param>
        /// <returns> Task that resolves to A single instance of MessagingItem </returns>
        #if !NET35
        public static async System.Threading.Tasks.Task<MessagingItemResource> UnscheduleAsync(UnscheduleMessagingItemOptions options,
                                                                                                          IReachRestClient client = null)
        {
            client = client ?? ReachClient.GetRestClient();
            var response = await client.RequestAsync(BuildUnscheduleRequest(options, client));
            return FromJson(response.Content);
        }
        #endif

        /// <summary> This operation allows to cancel a previously scheduled message.  This operation needs the `messageId` of the message to be unscheduled. To unschedule multiple messages, this operation should be called as many times needed since it can only unschedule one message at a time.  Note: The system will make the best attempt to cancel a scheduled message when a request is received.  </summary>
        /// <param name="messageId"> The identifier of the message to be unscheduled. </param>
        /// <param name="client"> Client to make requests to Reach(TalkyLabs) </param>
        /// <returns> A single instance of MessagingItem </returns>
        public static MessagingItemResource Unschedule(
                                          string messageId,
                                          IReachRestClient client = null)
        {
            var options = new UnscheduleMessagingItemOptions(messageId){  };
            return Unschedule(options, client);
        }

        #if !NET35
        /// <summary> This operation allows to cancel a previously scheduled message.  This operation needs the `messageId` of the message to be unscheduled. To unschedule multiple messages, this operation should be called as many times needed since it can only unschedule one message at a time.  Note: The system will make the best attempt to cancel a scheduled message when a request is received.  </summary>
        /// <param name="messageId"> The identifier of the message to be unscheduled. </param>
        /// <param name="client"> Client to make requests to Reach(TalkyLabs) </param>
        /// <returns> Task that resolves to A single instance of MessagingItem </returns>
        public static async System.Threading.Tasks.Task<MessagingItemResource> UnscheduleAsync(
                                                                              string messageId,
                                                                              IReachRestClient client = null)
        {
            var options = new UnscheduleMessagingItemOptions(messageId){  };
            return await UnscheduleAsync(options, client);
        }
        #endif
        
        private static Request BuildUpdateRequest(UpdateMessagingItemOptions options, IReachRestClient client)
        {
            
            string path = "/rest/messaging/v1/update";


            return new Request(
                HttpMethod.Post,
                Rest.Domain.Api,
                path,
                postParams: options.GetParams(),
                headerParams: null
            );
        }

        /// <summary> This operation allows to update the body of a message. It is primarily used to redact the content of message while leaving all the other properties untouched.  This operation needs the `messageId` of the message to be updated. It also requires the `body` that will be newly associated with the message. To update multiple messages, this operation should be called as many times as needed since it can only update one message at a time.  Note: The previous body of the message is the one that is sent to the destination phone number. This operation just update the `body` in the API platform.  </summary>
        /// <param name="options"> Update MessagingItem parameters </param>
        /// <param name="client"> Client to make requests to Reach(TalkyLabs) </param>
        /// <returns> A single instance of MessagingItem </returns>
        public static MessagingItemResource Update(UpdateMessagingItemOptions options, IReachRestClient client = null)
        {
            client = client ?? ReachClient.GetRestClient();
            var response = client.Request(BuildUpdateRequest(options, client));
            return FromJson(response.Content);
        }

        /// <summary> This operation allows to update the body of a message. It is primarily used to redact the content of message while leaving all the other properties untouched.  This operation needs the `messageId` of the message to be updated. It also requires the `body` that will be newly associated with the message. To update multiple messages, this operation should be called as many times as needed since it can only update one message at a time.  Note: The previous body of the message is the one that is sent to the destination phone number. This operation just update the `body` in the API platform.  </summary>
        /// <param name="options"> Update MessagingItem parameters </param>
        /// <param name="client"> Client to make requests to Reach(TalkyLabs) </param>
        /// <returns> Task that resolves to A single instance of MessagingItem </returns>
        #if !NET35
        public static async System.Threading.Tasks.Task<MessagingItemResource> UpdateAsync(UpdateMessagingItemOptions options,
                                                                                                          IReachRestClient client = null)
        {
            client = client ?? ReachClient.GetRestClient();
            var response = await client.RequestAsync(BuildUpdateRequest(options, client));
            return FromJson(response.Content);
        }
        #endif

        /// <summary> This operation allows to update the body of a message. It is primarily used to redact the content of message while leaving all the other properties untouched.  This operation needs the `messageId` of the message to be updated. It also requires the `body` that will be newly associated with the message. To update multiple messages, this operation should be called as many times as needed since it can only update one message at a time.  Note: The previous body of the message is the one that is sent to the destination phone number. This operation just update the `body` in the API platform.  </summary>
        /// <param name="messageId"> The identifier of the message to be updated. </param>
        /// <param name="body"> The text to be newly associated with the message. </param>
        /// <param name="client"> Client to make requests to Reach(TalkyLabs) </param>
        /// <returns> A single instance of MessagingItem </returns>
        public static MessagingItemResource Update(
                                          string messageId,
                                          string body,
                                          IReachRestClient client = null)
        {
            var options = new UpdateMessagingItemOptions(messageId, body){  };
            return Update(options, client);
        }

        #if !NET35
        /// <summary> This operation allows to update the body of a message. It is primarily used to redact the content of message while leaving all the other properties untouched.  This operation needs the `messageId` of the message to be updated. It also requires the `body` that will be newly associated with the message. To update multiple messages, this operation should be called as many times as needed since it can only update one message at a time.  Note: The previous body of the message is the one that is sent to the destination phone number. This operation just update the `body` in the API platform.  </summary>
        /// <param name="messageId"> The identifier of the message to be updated. </param>
        /// <param name="body"> The text to be newly associated with the message. </param>
        /// <param name="client"> Client to make requests to Reach(TalkyLabs) </param>
        /// <returns> Task that resolves to A single instance of MessagingItem </returns>
        public static async System.Threading.Tasks.Task<MessagingItemResource> UpdateAsync(
                                                                              string messageId,
                                                                              string body,
                                                                              IReachRestClient client = null)
        {
            var options = new UpdateMessagingItemOptions(messageId, body){  };
            return await UpdateAsync(options, client);
        }
        #endif
    
        /// <summary>
        /// Converts a JSON string into a MessagingItemResource object
        /// </summary>
        /// <param name="json"> Raw JSON string </param>
        /// <returns> MessagingItemResource object represented by the provided JSON </returns>
        public static MessagingItemResource FromJson(string json)
        {
            try
            {
                return JsonConvert.DeserializeObject<MessagingItemResource>(json);
            }
            catch (JsonException e)
            {
                throw new ApiException(e.Message, e);
            }
        }
        
        /// <summary>
        /// Converts this instance to a JSON string.
        /// </summary>
        /// <returns> a Json string of this object </returns>
        public string ToJson()
        {
            try
            {
                return JsonConvert.SerializeObject(this, Formatting.Indented);
            }
            catch (JsonException e)
            {
                throw new ApiException(e.Message, e);
            }
        }
        
        /// <summary>
        /// Convert to string
        /// </summary>
        /// <returns>String representation</returns>
        public override string ToString()
        {
        	try
            {
                return ToJson();
            }
            catch (ApiException e)
            {
                return base.ToString();
            }
        
        }

    
        ///<summary> The identifier of the applet sending the message. </summary> 
        [JsonProperty("appletId")]
        public string AppletId { get; private set; }

        ///<summary> The API version used to process the message. </summary> 
        [JsonProperty("apiVersion")]
        public string ApiVersion { get; private set; }

        ///<summary> The message text. </summary> 
        [JsonProperty("body")]
        public string Body { get; private set; }

        ///<summary> The phone number in E.164 format that received the message. </summary> 
        [JsonProperty("dest")]
        public string Dest { get; private set; }

        ///<summary> The phone number (in E.164 format), or the alphanumeric sender ID that initiated the message. </summary> 
        [JsonProperty("src")]
        public string Src { get; private set; }

        ///<summary> The bulk identifier allowing to group messages together and have corresponding statistics. </summary> 
        [JsonProperty("bulkId")]
        public string BulkId { get; private set; }

        ///<summary> The number of segments associated to the message. A message body that is too large to be sent in a single SMS is segmented and charged as multiple messages. The segments are reassembled once received by the destination phone. A message can have a maximum of 10 segments.  </summary> 
        [JsonProperty("numSegments")]
        public int? NumSegments { get; private set; }

        ///<summary> The number of media files included in the message </summary> 
        [JsonProperty("numMedia")]
        public int? NumMedia { get; private set; }

        ///<summary> The cost billed for the message, in the currency specified by `priceUnit`. </summary> 
        [JsonProperty("price")]
        public decimal? Price { get; private set; }

        ///<summary> The currency, in ISO 4127 format, in which price is measured. for example, usd, xaf, eur, cad. </summary> 
        [JsonProperty("priceUnit")]
        public string PriceUnit { get; private set; }

        ///<summary> The identifier of the message </summary> 
        [JsonProperty("messageId")]
        public string MessageId { get; private set; }

        ///<summary> The status of the message. Can be: `sent`, `scheduled`, `failed`, `delivered`, `undelivered`, `canceled`, `accepted`, `queued`, `sending`, `received`, `receiving`.   </summary> 
        [JsonProperty("status")]
        public string Status { get; private set; }

        ///<summary> The type of the message. Can be: `inbound` for incoming messages, `outbound` for messages initiated by a REST API.  </summary> 
        [JsonProperty("messageType")]
        public string MessageType { get; private set; }

        ///<summary> The error code returned if the message status is `failed` or `undelivered`. The errorMessage provides more information about the failure. The value is null if the message is successful.  </summary> 
        [JsonProperty("errorCode")]
        public int? ErrorCode { get; private set; }

        ///<summary> The error message returned if the message status is `failed` or `undelivered`.  The value is null if the message is successful.  </summary> 
        [JsonProperty("errorMessage")]
        public string ErrorMessage { get; private set; }

        ///<summary> The date and time in GMT that the message was created.  </summary> 
        [JsonProperty("dateCreated")]
        public DateTime? DateCreated { get; private set; }

        ///<summary> The date and time in GMT that the message was sent.  </summary> 
        [JsonProperty("dateSent")]
        public DateTime? DateSent { get; private set; }

        ///<summary> The date and time in GMT that the message status was last updated.  </summary> 
        [JsonProperty("dateUpdated")]
        public DateTime? DateUpdated { get; private set; }



        private MessagingItemResource() {

        }
    }
}

