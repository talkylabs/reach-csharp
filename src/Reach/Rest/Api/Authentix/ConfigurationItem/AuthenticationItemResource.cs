/*
 * This code was generated by
 *  ___ ___   _   ___ _  _    _____ _   _    _  ___   ___      _   ___ ___      ___   _   ___     ___ ___ _  _ ___ ___    _ _____ ___  ___ 
 * | _ \ __| /_\ / __| || |__|_   _/_\ | |  | |/ | \ / / |    /_\ | _ ) __|___ / _ \ /_\ |_ _|__ / __| __| \| | __| _ \  /_\_   _/ _ \| _ \
 * |   / _| / _ \ (__| __ |___|| |/ _ \| |__| ' < \ V /| |__ / _ \| _ \__ \___| (_) / _ \ | |___| (_ | _|| .` | _||   / / _ \| || (_) |   /
 * |_|_\___/_/ \_\___|_||_|    |_/_/ \_\____|_|\_\ |_| |____/_/ \_\___/___/    \___/_/ \_\___|   \___|___|_|\_|___|_|_\/_/ \_\_| \___/|_|_\
 *                                                                                                                                         
 * Reach Authentix API
 *  Reach Authentix API helps you easily integrate user authentification in your application. The authentification allows to verify that a user is indeed at the origin of a request from your application.  At the moment, the Reach Authentix API supports the following channels:    * SMS      * Email   We are continuously working to add additionnal channels. ## Base URL All endpoints described in this documentation are relative to the following base URL: ``` https://api.reach.talkylabs.com/rest/authentix/v1/ ```  The API is provided over HTTPS protocol to ensure data privacy.  ## API Authentication Requests made to the API must be authenticated. You need to provide the `ApiUser` and `ApiKey` associated with your applet. This information could be found in the settings of the applet. ```curl curl -X GET [BASE_URL]/configurations -H \"ApiUser:[Your_Api_User]\" -H \"ApiKey:[Your_Api_Key]\" ``` ## Reach Authentix API Workflow Three steps are needed in order to authenticate a given user using the Reach Authentix API. ### Step 1: Create an Authentix configuration A configuration is a set of settings used to define and send an authentication code to a user. This includes, for example: ```   - the length of the authentication code,    - the message template,    - and so on... ``` A configuaration could be created via the web application or directly using the Reach Authentix API. This step does not need to be performed every time one wants to use the Reach Authentix API. Indeed, once created, a configuartion could be used to authenticate several users in the future.    ### Step 2: Send an authentication code A configuration is used to send an authentication code via a selected channel to a user. For now, the supported channels are `sms`, and `email`. We are working hard to support additional channels. Newly created authentications will have a status of `awaiting`. ### Step 3: Verify the authentication code This step allows to verify that the code submitted by the user matched the one sent previously. If, there is a match, then the status of the authentication changes from `awaiting` to `passed`. Otherwise, the status remains `awaiting` until either it is verified or it expires. In the latter case, the status becomes `expired`. 
 *
 * NOTE: This class is auto generated by OpenAPI Generator.
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


using Newtonsoft.Json;
using System;
using System.Collections.Generic;
using Reach.Base;
using Reach.Clients;
using Reach.Converters;
using Reach.Exceptions;
using Reach.Http;
using Reach.Types;


namespace Reach.Rest.Api.Authentix.ConfigurationItem
{
    public class AuthenticationItemResource : Resource
    {
    
        public sealed class StatusEnum : StringEnum
        {
            private StatusEnum(string value) : base(value) {}
            public StatusEnum() {}
            public static implicit operator StatusEnum(string value)
            {
                return new StatusEnum(value);
            }
            public static readonly StatusEnum Passed = new StatusEnum("passed");
            public static readonly StatusEnum Canceled = new StatusEnum("canceled");

        }
        public sealed class ChannelEnum : StringEnum
        {
            private ChannelEnum(string value) : base(value) {}
            public ChannelEnum() {}
            public static implicit operator ChannelEnum(string value)
            {
                return new ChannelEnum(value);
            }
            public static readonly ChannelEnum Sms = new ChannelEnum("sms");
            public static readonly ChannelEnum Email = new ChannelEnum("email");

        }

        
        private static Request BuildFetchRequest(FetchAuthenticationItemOptions options, IReachRestClient client)
        {
            
            string path = "/rest/authentix/v1/configurations/{configurationId}/authentications/{authenticationId}";

            string PathConfigurationId = options.PathConfigurationId;
            path = path.Replace("{"+"configurationId"+"}", PathConfigurationId);
            string PathAuthenticationId = options.PathAuthenticationId;
            path = path.Replace("{"+"authenticationId"+"}", PathAuthenticationId);

            return new Request(
                HttpMethod.Get,
                Rest.Domain.Api,
                path,
                queryParams: options.GetParams(),
                headerParams: null
            );
        }

        /// <summary> This operation allows to fetch the API record associated to an authentication.    </summary>
        /// <param name="options"> Fetch AuthenticationItem parameters </param>
        /// <param name="client"> Client to make requests to Reach(TalkyLabs) </param>
        /// <returns> A single instance of AuthenticationItem </returns>
        public static AuthenticationItemResource Fetch(FetchAuthenticationItemOptions options, IReachRestClient client = null)
        {
            client = client ?? ReachClient.GetRestClient();
            var response = client.Request(BuildFetchRequest(options, client));
            return FromJson(response.Content);
        }

        #if !NET35
        /// <summary> This operation allows to fetch the API record associated to an authentication.    </summary>
        /// <param name="options"> Fetch AuthenticationItem parameters </param>
        /// <param name="client"> Client to make requests to Reach(TalkyLabs) </param>
        /// <returns> Task that resolves to A single instance of AuthenticationItem </returns>
        public static async System.Threading.Tasks.Task<AuthenticationItemResource> FetchAsync(FetchAuthenticationItemOptions options,
                                                                                             IReachRestClient client = null)
        {
            client = client ?? ReachClient.GetRestClient();
            var response = await client.RequestAsync(BuildFetchRequest(options, client));
            return FromJson(response.Content);
        }
        #endif
        /// <summary> This operation allows to fetch the API record associated to an authentication.    </summary>
        /// <param name="pathConfigurationId"> The identifier of the configuration being used. </param>
        /// <param name="pathAuthenticationId"> The identifier of the authentication to be fetched. </param>
        /// <param name="client"> Client to make requests to Reach(TalkyLabs) </param>
        /// <returns> A single instance of AuthenticationItem </returns>
        public static AuthenticationItemResource Fetch(
                                         string pathConfigurationId, 
                                         string pathAuthenticationId, 
                                         IReachRestClient client = null)
        {
            var options = new FetchAuthenticationItemOptions(pathConfigurationId, pathAuthenticationId){  };
            return Fetch(options, client);
        }

        #if !NET35
        /// <summary> This operation allows to fetch the API record associated to an authentication.    </summary>
        /// <param name="pathConfigurationId"> The identifier of the configuration being used. </param>
        /// <param name="pathAuthenticationId"> The identifier of the authentication to be fetched. </param>
        /// <param name="client"> Client to make requests to Reach(TalkyLabs) </param>
        /// <returns> Task that resolves to A single instance of AuthenticationItem </returns>
        public static async System.Threading.Tasks.Task<AuthenticationItemResource> FetchAsync(string pathConfigurationId, string pathAuthenticationId, IReachRestClient client = null)
        {
            var options = new FetchAuthenticationItemOptions(pathConfigurationId, pathAuthenticationId){  };
            return await FetchAsync(options, client);
        }
        #endif
        
        private static Request BuildReadRequest(ReadAuthenticationItemOptions options, IReachRestClient client)
        {
            
            string path = "/rest/authentix/v1/configurations/{configurationId}/authentications";

            string PathConfigurationId = options.PathConfigurationId;
            path = path.Replace("{"+"configurationId"+"}", PathConfigurationId);

            return new Request(
                HttpMethod.Get,
                Rest.Domain.Api,
                path,
                queryParams: options.GetParams(),
                headerParams: null
            );
        }
        /// <summary> This operation allows to retrieve all authentications generated from a given configuration that are not expired and for which the number of maximum trials/controls is not exceeded.  When getting the authentication list, results will be sorted based  on the `dateCreated` field with the most recent record appearing first.  </summary>
        /// <param name="options"> Read AuthenticationItem parameters </param>
        /// <param name="client"> Client to make requests to Reach(TalkyLabs) </param>
        /// <returns> A single instance of AuthenticationItem </returns>
        public static ResourceSet<AuthenticationItemResource> Read(ReadAuthenticationItemOptions options, IReachRestClient client = null)
        {
            client = client ?? ReachClient.GetRestClient();
            var request = BuildReadRequest(options, client);
            var url = request.GetUrlStringWithoutPaginationInfo();
            var response = client.Request(request);
            var page = Page<AuthenticationItemResource>.FromJson(url, "authentications", response.Content);
            return new ResourceSet<AuthenticationItemResource>(page, options, client);
        }

        #if !NET35
        /// <summary> This operation allows to retrieve all authentications generated from a given configuration that are not expired and for which the number of maximum trials/controls is not exceeded.  When getting the authentication list, results will be sorted based  on the `dateCreated` field with the most recent record appearing first.  </summary>
        /// <param name="options"> Read AuthenticationItem parameters </param>
        /// <param name="client"> Client to make requests to Reach(TalkyLabs) </param>
        /// <returns> Task that resolves to A single instance of AuthenticationItem </returns>
        public static async System.Threading.Tasks.Task<ResourceSet<AuthenticationItemResource>> ReadAsync(ReadAuthenticationItemOptions options,
                                                                                             IReachRestClient client = null)
        {
            client = client ?? ReachClient.GetRestClient();
            var request = BuildReadRequest(options, client);
            var url = request.GetUrlStringWithoutPaginationInfo();
            var response = await client.RequestAsync(request);

            var page = Page<AuthenticationItemResource>.FromJson(url, "authentications", response.Content);
            return new ResourceSet<AuthenticationItemResource>(page, options, client);
        }
        #endif
        /// <summary> This operation allows to retrieve all authentications generated from a given configuration that are not expired and for which the number of maximum trials/controls is not exceeded.  When getting the authentication list, results will be sorted based  on the `dateCreated` field with the most recent record appearing first.  </summary>
        /// <param name="pathConfigurationId"> The identifier of the configuration being used. </param>
        /// <param name="pageSize"> Maximum number of records to return per call. </param>
        /// <param name="limit"> Record limit </param>
        /// <param name="client"> Client to make requests to Reach(TalkyLabs) </param>
        /// <returns> A single instance of AuthenticationItem </returns>
        public static ResourceSet<AuthenticationItemResource> Read(
                                                     string pathConfigurationId,
                                                     int? pageSize = null,
                                                     long? limit = null,
                                                     IReachRestClient client = null)
        {
            var options = new ReadAuthenticationItemOptions(pathConfigurationId){ PageSize = pageSize, Limit = limit};
            return Read(options, client);
        }

        #if !NET35
        /// <summary> This operation allows to retrieve all authentications generated from a given configuration that are not expired and for which the number of maximum trials/controls is not exceeded.  When getting the authentication list, results will be sorted based  on the `dateCreated` field with the most recent record appearing first.  </summary>
        /// <param name="pathConfigurationId"> The identifier of the configuration being used. </param>
        /// <param name="pageSize"> Maximum number of records to return per call. </param>
        /// <param name="limit"> Record limit </param>
        /// <param name="client"> Client to make requests to Reach(TalkyLabs) </param>
        /// <returns> Task that resolves to A single instance of AuthenticationItem </returns>
        public static async System.Threading.Tasks.Task<ResourceSet<AuthenticationItemResource>> ReadAsync(
                                                                                             string pathConfigurationId,
                                                                                             int? pageSize = null,
                                                                                             long? limit = null,
                                                                                             IReachRestClient client = null)
        {
            var options = new ReadAuthenticationItemOptions(pathConfigurationId){ PageSize = pageSize, Limit = limit};
            return await ReadAsync(options, client);
        }
        #endif

        
        /// <summary> Fetch the target page of records </summary>
        /// <param name="targetUrl"> API-generated URL for the requested results page </param>
        /// <param name="client"> Client to make requests to Reach(TalkyLabs) </param>
        /// <returns> The target page of records </returns>
        public static Page<AuthenticationItemResource> GetPage(string targetUrl, IReachRestClient client)
        {
            client = client ?? ReachClient.GetRestClient();

            var request = new Request(
                HttpMethod.Get,
                targetUrl
            );

            var url = request.GetUrlStringWithoutPaginationInfo();
            var response = client.Request(request);
            return Page<AuthenticationItemResource>.FromJson(url, "authentications", response.Content);
        }

        /// <summary> Fetch the next page of records </summary>
        /// <param name="page"> current page of records </param>
        /// <param name="client"> Client to make requests to Reach(TalkyLabs) </param>
        /// <returns> The next page of records </returns>
        public static Page<AuthenticationItemResource> NextPage(Page<AuthenticationItemResource> page, IReachRestClient client)
        {
            var request = new Request(
                HttpMethod.Get,
                page.GetNextPageUrl(Rest.Domain.Api)
            );

            var url = request.GetUrlStringWithoutPaginationInfo();
            var response = client.Request(request);
            return Page<AuthenticationItemResource>.FromJson(url, "authentications", response.Content);
        }

        /// <summary> Fetch the previous page of records </summary>
        /// <param name="page"> current page of records </param>
        /// <param name="client"> Client to make requests to Reach(TalkyLabs) </param>
        /// <returns> The previous page of records </returns>
        public static Page<AuthenticationItemResource> PreviousPage(Page<AuthenticationItemResource> page, IReachRestClient client)
        {
            var request = new Request(
                HttpMethod.Get,
                page.GetPreviousPageUrl(Rest.Domain.Api)
            );

            var url = request.GetUrlStringWithoutPaginationInfo();
            var response = client.Request(request);
            return Page<AuthenticationItemResource>.FromJson(url, "authentications", response.Content);
        }

        
        private static Request BuildStartRequest(StartAuthenticationItemOptions options, IReachRestClient client)
        {
            
            string path = "/rest/authentix/v1/configurations/{configurationId}/authentications";

            string PathConfigurationId = options.PathConfigurationId;
            path = path.Replace("{"+"configurationId"+"}", PathConfigurationId);

            return new Request(
                HttpMethod.Post,
                Rest.Domain.Api,
                path,
                postParams: options.GetParams(),
                headerParams: null
            );
        }

        /// <summary> This operation allows to start a new authentication process by sending a code via a specific channel.  </summary>
        /// <param name="options"> Start AuthenticationItem parameters </param>
        /// <param name="client"> Client to make requests to Reach(TalkyLabs) </param>
        /// <returns> A single instance of AuthenticationItem </returns>
        public static AuthenticationItemResource Start(StartAuthenticationItemOptions options, IReachRestClient client = null)
        {
            client = client ?? ReachClient.GetRestClient();
            var response = client.Request(BuildStartRequest(options, client));
            return FromJson(response.Content);
        }

        #if !NET35
        /// <summary> This operation allows to start a new authentication process by sending a code via a specific channel.  </summary>
        /// <param name="options"> Start AuthenticationItem parameters </param>
        /// <param name="client"> Client to make requests to Reach(TalkyLabs) </param>
        /// <returns> Task that resolves to A single instance of AuthenticationItem </returns>
        public static async System.Threading.Tasks.Task<AuthenticationItemResource> StartAsync(StartAuthenticationItemOptions options,
        IReachRestClient client = null)
        {
            client = client ?? ReachClient.GetRestClient();
            var response = await client.RequestAsync(BuildStartRequest(options, client));
            return FromJson(response.Content);
        }
        #endif

        /// <summary> This operation allows to start a new authentication process by sending a code via a specific channel.  </summary>
        /// <param name="pathConfigurationId"> The identifier of the configuration being used. </param>
        /// <param name="dest"> The phone number or email where to send the authentication code. Phone numbers must be in E.164 format. </param>
        /// <param name="channel"> The channel by which the authentication code is sent. </param>
        /// <param name="serviceName"> a service name overwriting the one defined in the configuration. </param>
        /// <param name="customCode"> the pre-generated code to be sent. Its length should be between 4 and 10 inclusive. </param>
        /// <param name="paymentInfo"> Information related to the digital payment to authenticate. It is required when `usedForDigitalPayment` is true. It is ignored otherwise. It is a stringfied JSON map where keys are `payee`, `amount`, and `currency` and the associated values are respectively the payee, the amount, and the currency of a financial transaction.  </param>
        /// <param name="templateId"> This is the ID of the message template to use for sending the authenetication code. It could be an sms or email template depending on the channel being used. It overwirites the template ID defined in the configuration if any.  </param>
        /// <param name="templateDataMap"> A stringfied JSON map where keys are message template parameters and the values are the parameter values to be used when sending the authentication code. It may also be used to provide additional parameters for sending email based authentications such as the email used for sending the code. </param>
        /// <param name="client"> Client to make requests to Reach(TalkyLabs) </param>
        /// <returns> A single instance of AuthenticationItem </returns>
        public static AuthenticationItemResource Start(
                                          string pathConfigurationId,
                                          string dest,
                                          AuthenticationItemResource.ChannelEnum channel,
                                          string serviceName = null,
                                          string customCode = null,
                                          string paymentInfo = null,
                                          string templateId = null,
                                          string templateDataMap = null,
                                          IReachRestClient client = null)
        {
            var options = new StartAuthenticationItemOptions(pathConfigurationId, dest, channel){  ServiceName = serviceName, CustomCode = customCode, PaymentInfo = paymentInfo, TemplateId = templateId, TemplateDataMap = templateDataMap };
            return Start(options, client);
        }

        #if !NET35
        /// <summary> This operation allows to start a new authentication process by sending a code via a specific channel.  </summary>
        /// <param name="pathConfigurationId"> The identifier of the configuration being used. </param>
        /// <param name="dest"> The phone number or email where to send the authentication code. Phone numbers must be in E.164 format. </param>
        /// <param name="channel"> The channel by which the authentication code is sent. </param>
        /// <param name="serviceName"> a service name overwriting the one defined in the configuration. </param>
        /// <param name="customCode"> the pre-generated code to be sent. Its length should be between 4 and 10 inclusive. </param>
        /// <param name="paymentInfo"> Information related to the digital payment to authenticate. It is required when `usedForDigitalPayment` is true. It is ignored otherwise. It is a stringfied JSON map where keys are `payee`, `amount`, and `currency` and the associated values are respectively the payee, the amount, and the currency of a financial transaction.  </param>
        /// <param name="templateId"> This is the ID of the message template to use for sending the authenetication code. It could be an sms or email template depending on the channel being used. It overwirites the template ID defined in the configuration if any.  </param>
        /// <param name="templateDataMap"> A stringfied JSON map where keys are message template parameters and the values are the parameter values to be used when sending the authentication code. It may also be used to provide additional parameters for sending email based authentications such as the email used for sending the code. </param>
        /// <param name="client"> Client to make requests to Reach(TalkyLabs) </param>
        /// <returns> Task that resolves to A single instance of AuthenticationItem </returns>
        public static async System.Threading.Tasks.Task<AuthenticationItemResource> StartAsync(
                                                                                  string pathConfigurationId,
                                                                                  string dest,
                                                                                  AuthenticationItemResource.ChannelEnum channel,
                                                                                  string serviceName = null,
                                                                                  string customCode = null,
                                                                                  string paymentInfo = null,
                                                                                  string templateId = null,
                                                                                  string templateDataMap = null,
                                                                                  IReachRestClient client = null)
        {
        var options = new StartAuthenticationItemOptions(pathConfigurationId, dest, channel){  ServiceName = serviceName, CustomCode = customCode, PaymentInfo = paymentInfo, TemplateId = templateId, TemplateDataMap = templateDataMap };
            return await StartAsync(options, client);
        }
        #endif
        
        private static Request BuildUpdateRequest(UpdateAuthenticationItemOptions options, IReachRestClient client)
        {
            
            string path = "/rest/authentix/v1/configurations/{configurationId}/authentications/{authenticationId}";

            string PathConfigurationId = options.PathConfigurationId;
            path = path.Replace("{"+"configurationId"+"}", PathConfigurationId);
            string PathAuthenticationId = options.PathAuthenticationId;
            path = path.Replace("{"+"authenticationId"+"}", PathAuthenticationId);

            return new Request(
                HttpMethod.Post,
                Rest.Domain.Api,
                path,
                postParams: options.GetParams(),
                headerParams: null
            );
        }

        /// <summary> This operation allows to manually update the status of an authentication. This should only be used with custom code authentications.  Set the authentication status to \"passed\" after you validated the authentication code. Similarly, set the authentication status to \"canceled\" if you want to restart start a new authentication with a different code.  When not using custom codes, there is no need to used this method as the REACH Authentix API can manage the whole life cycle of an authentication.  </summary>
        /// <param name="options"> Update AuthenticationItem parameters </param>
        /// <param name="client"> Client to make requests to Reach(TalkyLabs) </param>
        /// <returns> A single instance of AuthenticationItem </returns>
        public static AuthenticationItemResource Update(UpdateAuthenticationItemOptions options, IReachRestClient client = null)
        {
            client = client ?? ReachClient.GetRestClient();
            var response = client.Request(BuildUpdateRequest(options, client));
            return FromJson(response.Content);
        }

        /// <summary> This operation allows to manually update the status of an authentication. This should only be used with custom code authentications.  Set the authentication status to \"passed\" after you validated the authentication code. Similarly, set the authentication status to \"canceled\" if you want to restart start a new authentication with a different code.  When not using custom codes, there is no need to used this method as the REACH Authentix API can manage the whole life cycle of an authentication.  </summary>
        /// <param name="options"> Update AuthenticationItem parameters </param>
        /// <param name="client"> Client to make requests to Reach(TalkyLabs) </param>
        /// <returns> Task that resolves to A single instance of AuthenticationItem </returns>
        #if !NET35
        public static async System.Threading.Tasks.Task<AuthenticationItemResource> UpdateAsync(UpdateAuthenticationItemOptions options,
                                                                                                          IReachRestClient client = null)
        {
            client = client ?? ReachClient.GetRestClient();
            var response = await client.RequestAsync(BuildUpdateRequest(options, client));
            return FromJson(response.Content);
        }
        #endif

        /// <summary> This operation allows to manually update the status of an authentication. This should only be used with custom code authentications.  Set the authentication status to \"passed\" after you validated the authentication code. Similarly, set the authentication status to \"canceled\" if you want to restart start a new authentication with a different code.  When not using custom codes, there is no need to used this method as the REACH Authentix API can manage the whole life cycle of an authentication.  </summary>
        /// <param name="pathConfigurationId"> The identifier of the configuration being used. </param>
        /// <param name="pathAuthenticationId"> The identifier of the authentication to be updated. </param>
        /// <param name="status"> The new status of the authentication. </param>
        /// <param name="client"> Client to make requests to Reach(TalkyLabs) </param>
        /// <returns> A single instance of AuthenticationItem </returns>
        public static AuthenticationItemResource Update(
                                          string pathConfigurationId,
                                          string pathAuthenticationId,
                                          AuthenticationItemResource.StatusEnum status,
                                          IReachRestClient client = null)
        {
            var options = new UpdateAuthenticationItemOptions(pathConfigurationId, pathAuthenticationId, status){  };
            return Update(options, client);
        }

        #if !NET35
        /// <summary> This operation allows to manually update the status of an authentication. This should only be used with custom code authentications.  Set the authentication status to \"passed\" after you validated the authentication code. Similarly, set the authentication status to \"canceled\" if you want to restart start a new authentication with a different code.  When not using custom codes, there is no need to used this method as the REACH Authentix API can manage the whole life cycle of an authentication.  </summary>
        /// <param name="pathConfigurationId"> The identifier of the configuration being used. </param>
        /// <param name="pathAuthenticationId"> The identifier of the authentication to be updated. </param>
        /// <param name="status"> The new status of the authentication. </param>
        /// <param name="client"> Client to make requests to Reach(TalkyLabs) </param>
        /// <returns> Task that resolves to A single instance of AuthenticationItem </returns>
        public static async System.Threading.Tasks.Task<AuthenticationItemResource> UpdateAsync(
                                                                              string pathConfigurationId,
                                                                              string pathAuthenticationId,
                                                                              AuthenticationItemResource.StatusEnum status,
                                                                              IReachRestClient client = null)
        {
            var options = new UpdateAuthenticationItemOptions(pathConfigurationId, pathAuthenticationId, status){  };
            return await UpdateAsync(options, client);
        }
        #endif
    
        /// <summary>
        /// Converts a JSON string into a AuthenticationItemResource object
        /// </summary>
        /// <param name="json"> Raw JSON string </param>
        /// <returns> AuthenticationItemResource object represented by the provided JSON </returns>
        public static AuthenticationItemResource FromJson(string json)
        {
            try
            {
                return JsonConvert.DeserializeObject<AuthenticationItemResource>(json);
            }
            catch (JsonException e)
            {
                throw new ApiException(e.Message, e);
            }
        }
        
        /// <summary>
        /// Converts this instance to a JSON string.
        /// </summary>
        /// <returns> a Json string of this object </returns>
        public string ToJson()
        {
            try
            {
                return JsonConvert.SerializeObject(this, Formatting.Indented);
            }
            catch (JsonException e)
            {
                throw new ApiException(e.Message, e);
            }
        }
        
        /// <summary>
        /// Convert to string
        /// </summary>
        /// <returns>String representation</returns>
        public override string ToString()
        {
        	try
            {
                return ToJson();
            }
            catch (ApiException e)
            {
                return base.ToString();
            }
        
        }

    
        ///<summary> The identifier of the applet. </summary> 
        [JsonProperty("appletId")]
        public string AppletId { get; private set; }

        ///<summary> The API version. </summary> 
        [JsonProperty("apiVersion")]
        public string ApiVersion { get; private set; }

        ///<summary> The identifier of the configuration. </summary> 
        [JsonProperty("configurationId")]
        public string ConfigurationId { get; private set; }

        ///<summary> The identifier of the authentication. </summary> 
        [JsonProperty("authenticationId")]
        public string AuthenticationId { get; private set; }

        ///<summary> The status of the authentication. </summary> 
        [JsonProperty("status")]
        public string Status { get; private set; }

        ///<summary> The destination of the authentication code. Phone numbers must be in E.164 format. </summary> 
        [JsonProperty("dest")]
        public string Dest { get; private set; }

        ///<summary> The channel used. </summary> 
        [JsonProperty("channel")]
        public string Channel { get; private set; }

        ///<summary> An expiry time in minutes.  </summary> 
        [JsonProperty("expiryTime")]
        public int? ExpiryTime { get; private set; }

        ///<summary> The maximum number of trials.  </summary> 
        [JsonProperty("maxTrials")]
        public int? MaxTrials { get; private set; }

        ///<summary> The maximum number of code controls.  </summary> 
        [JsonProperty("maxControls")]
        public int? MaxControls { get; private set; }

        ///<summary> The paymentInfo </summary> 
        [JsonProperty("paymentInfo")]
        public PaymentInfo PaymentInfo { get; private set; }

        ///<summary> An array of authentication trials containing channel-specific information about each trial. </summary> 
        [JsonProperty("trials")]
        public List<TrialQuickInfo> Trials { get; private set; }

        ///<summary> The date and time in GMT that the authentication was created.  </summary> 
        [JsonProperty("dateCreated")]
        public DateTime? DateCreated { get; private set; }

        ///<summary> The date and time in GMT that the authentication was last updated.  </summary> 
        [JsonProperty("dateUpdated")]
        public DateTime? DateUpdated { get; private set; }



        private AuthenticationItemResource() {

        }
    }
}

